#!/usr/bin/env python3

import sys
import re
import fnmatch
import os
import glob

#
# Functions
#

def isempty(string):
    return len(string) == 0

def startsQuiz(string):
    return not isempty(string) and string[0] == '?'

def parseQuestion(string):
    if string[0] in ['?', '%', 'V', 'X']:
        return string[1:].strip()
    return string.strip()

def concatenateMultiline(lines):

    newLines = []

    for line in lines:
        if isempty(line) or line[0] != '|':
            newLines.append(line.strip())

        else:
            newLines[-1] = newLines[-1] + '<br>' + line[1:].strip()

    return newLines

def isAnswer(string):
    return not isempty(string) and string[0] == 'V'


def findOtherQuestions(lines):

    lastEmpty = True
    question = None

    questions = {}

    for line in lines:

        if isempty(line):
            lastEmpty = True
            question = None
            continue

        elif lastEmpty and line[0] in ['?', '%']:
            lastEmpty = False
            question = None
            continue

        elif question is not None:
            answer = line

            questions[question] = answer

        elif lastEmpty:
            question = line


    return questions

def findQuizes(lines):
    quizes = {}

    for i in range(len(lines)):

        if startsQuiz(lines[i]):
            originalQuestion = question = parseQuestion( lines[i] )
            options = []
            answer = None

            # Go through answers for qestion
            for j in range(i+1, len(lines)):

                if isempty(lines[j]):
                    break

                if isAnswer(lines[j]):

                    if answer is not None:
                        raise Exception("Multiple answers given", originalQuestion)

                    answer = lines[j][1:].strip()

                options.append(lines[j][1:].strip())

            if answer is None:
                raise Exception("No answer given", originalQuestion)

            question += '<br>'

            # Add options to question
            for option in options:
                question += '<br>' + option

            quizes[question] = answer

    return quizes

def findBlanks(lines):

    blanks = {}
    delimiter = '___'

    for line in lines:

        indexes = [ index.start() for index in re.finditer(delimiter, line) ]

        if not isempty(indexes):

            question = blankOut(line, indexes)
            answer = line[ indexes[0] + len(delimiter) : indexes[1] ]

            blanks[question] = answer

    return blanks


def blankOut(string, indexes):
    res = ''
    for i in range(len(string)):
        if i in range(indexes[0], indexes[1]):
            res += '_'
        else:
            res += string[i]
    return res

def blankIndexes(string):
    return [ m.start() for m in re.finditer('___', string)]

def generateSingleFromMultipleBlanks(originalQuestion, steps):
    result = {}

    for step1 in steps:
        question = originalQuestion + '<br>'
        answer = None

        for step2 in steps:
            if step1 == step2:
                question += '<br>______'
                answer = step1
            else:
                question += '<br>' + step2

        result[question] = answer

    return result

def findMultipleBlanks(lines):

    result = {}
    started = False

    question = None
    options = []

    for line in lines:
        if isempty(line):

            if not question is None:
                result.update( generateSingleFromMultipleBlanks(question, options) )

            question = None
            continue

        if line[0] == '%':
            question = line[1:]
            continue

        if not question is None:
            options.append(line)

    return result

def escapeDoubleQuotes(lines):
    newLines = []
    for line in lines:
        newLines.append( line.replace('"', '""') )
    return newLines

def parseQuestions(questions):

    result = []

    for question in questions:
        current = ''

        current += '"' + question + '", '
        current += '"' + questions[question] + '"'

        result.append(current)

    return result

def parseVariables(lines):
    res = []
    variables = {}

    for line in lines:

        for variable in variables:
            # Regex could match the variable name, so I decided to include
            # the most common variants of interpolation instead
            line = line.replace('${%s}' % variable, variables[variable])
            line = line.replace('${ %s }' % variable, variables[variable])
            line = line.replace('${ %s}' % variable, variables[variable])
            line = line.replace('${%s }' % variable, variables[variable])
            line = line.replace('${  %s }' % variable, variables[variable])
            line = line.replace('${  %s  }' % variable, variables[variable])
            line = line.replace('${ %s  }' % variable, variables[variable])

        if line.strip().startswith('DEFINE'):
            declaration = list(map(lambda string: string.strip(), line.strip()[len("DEFINE"):].split('=')))
            if len(declaration) != 2:
                raise Exception('Invalid number of arguments for a variable declaration:', len(declaration), 'for', declaration)
            variables[declaration[0]] = declaration[1]

        else:
            res.append(line)

    return res

def process(lines):
    # escape double quotes
    lines = escapeDoubleQuotes(lines)

    # Concatenate multiline blocks
    lines = concatenateMultiline(lines)

    # Variables
    lines = parseVariables(lines)

    # Trim lines
    lines = map(lambda string: string.strip(), lines)

    # Remove commented out lines
    lines = list( filter(lambda string: isempty(string) or string[0] != '#', lines) )

    # Find quizes
    quizes = findQuizes(lines)

    # Find question with blanks
    blanks = findBlanks(lines)

    # Find question with multiple blanks
    multipleBlanks = findMultipleBlanks(lines)

    # Find other questions
    other = findOtherQuestions(lines)

    # Concatenate all questions to one list
    questions = {}
    for d in [quizes, blanks, multipleBlanks, other]:
        questions.update(d)

    # Convert dictionaries into csv format
    parsedLines = parseQuestions(questions)

    return parsedLines

def processFile(filename):
    print('Sourcing anki from ', filename)

    fileStream = open(filename, 'r')
    lines = fileStream.readlines()
    fileStream.close()

    parsedLines = process(lines)

    # Output file name should match input file name but with csv-suffix
    outputFileName = filename[:len(filename) - len(suffix)] + '.csv';
    print('Storing result to:', outputFileName)

    outputFile = open( outputFileName, 'w' )

    for line in parsedLines:
        outputFile.write(line + '\n')


#
# Primary logic
#

suffix = '.ankisource'

if len(sys.argv) < 2 or not sys.argv[1].endswith(suffix):
    print('Input file of type %s required' % suffix)
    exit(0)

for i in range(1, len(sys.argv)):
    filename = sys.argv[i]
    processFile(filename)


